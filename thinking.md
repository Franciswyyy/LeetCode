
### Sum
 * 2个数相加: 数的具体位置
    - 用HashMap的key存值，val存位置
    -  循环，n平方
 * 3个数相加：
    - 没有要求具体的位置，所以一般排好序
    - 去掉重复的,加个if方法  -4 -1 -1 0 1 2
    - 找到后也要把相同的筛选 -2 0 0 2 2
 * 4个数相加：
    - 类似推广，把第一个值固定循环，开始找3个数等于指定的target
 * 最接近的3个数和，类似3Sum
	- 排好序
	- 3个指针指向当前，下一个，最后一个元素
	- 小的话，加大，反之。
 * 两个数的和：
    - 已经是有序的，打印下标
	- 一前一后依次遍历
 * bst两个数的和：
	- bst前序遍历是一个有序序列
	- 数组在不知道新建多大的情况下，可以直接用集合类ArrayList，会自动扩容
 * 子数组等于k
	- 我的思路：暴力递归，以长度1,2,3...依次递增来循环寻找有没有
	- 从第一个数开始，依次的第一个，第二个累加来算，第一遍完了之后，接着第二个数，依次遍历
	- 常用的haspmap来解决这一类问题
 * 4个数组相加：
	- 4个数组两两遍历
	- hashmap装一个值，来找有没有相反的

	============
	
### best time to buy and sell stock 
	* I. 最多一笔交易，得到最大利益:  
	   - 求一个数组的最大值和最小值，且最小值在其左边，否则求次小的值
	   - 暴力求解	
	   - Kadane算法
	   - 动态规划：两个变量，最低买入价格和当前可达到最高利润
	* II. 尽可能多的交易，购买前出售股票
	   - 只要是递增的都是算有收益的(贪心：只要当前比前一天大，就卖股票)
	   
	   考虑一个问题： 1,3,5,6 如果题目规定当天不能同时买卖的话，那么应该是6-1=5而不是3-1 + 6-5 = 3。
							  如果规定可以同时买的话，3-1 + 5-3 + 6-5 = 5
	 III 假设没有钱，
	     buy1意味着不得不想别人借钱，希望少借款，以达到余额最大（这个是负数，欠的）
	     sell1 出售股票了，出售之后必须退我们欠的钱，
	     buy2 买另一个股票，已经有有钱了， 则购买剩下的钱要更多
	     sell2卖出股票之后，以及还有之前买2剩下的钱，这个是最大值
	     
